"use client";

import { useMemo } from "react";
import { useParams } from "next/navigation";
import Link from "next/link";
import benchmarkResults from "../../../../benchmark/results.json";
import humanResults from "../../../../benchmark/results-human.json";
import { Table } from "../../components/table";
import { Badge } from "../../components/badge";
import { ArrowLeftIcon } from "@/app/components/icons";
import { PreviewModal } from "@/app/components/code-preview";
import { getExactnessScore } from "@/lib/eval";

type BenchmarkResult = {
  provider: string;
  model: string;
  name: string;
  question: {
    name: string;
    content: string;
  };
  sql?: string;
  sqlResult?: {
    success: boolean;
    data: Record<string, unknown>[];
    meta?: { name: string; type: string }[];
    statistics?: {
      elapsed: number;
      rows_read: number;
      bytes_read: number;
    };
    executionTime: number;
    requestId: string;
  };
  metrics?: {
    timeToFirstToken: number;
    totalDuration: number;
    tokens?: {
      totalTokens: number;
    };
  };
  attempts?: Array<{
    question: {
      question: string;
    };
  }>;
};

const typedBenchmarkResults = benchmarkResults as unknown as BenchmarkResult[];
const typedHumanResults = humanResults as unknown as BenchmarkResult[];

type QuestionMetric = {
  name: string;
  model: string;
  question: string;
  sql: string;
  executionTime: number;
  timeToFirstToken: number;
  totalDuration: number;
  bytesRead: number;
  rowsRead: number;
  queryLength: number;
  attempts: Array<{ question: { question: string } }>;
  success: boolean;
  firstAttempt: boolean;
  exactnessScore: number;
  tokens: number;
};

function calculateQuestionMetrics(result: BenchmarkResult): QuestionMetric {
  const exactnessScore = getExactnessScore(
    result.provider,
    result.model,
    result.question.name
  );

  return {
    name: result.name,
    model: result.model,
    question: result.question.content,
    sql: result.sql || "",
    executionTime: result.sqlResult?.executionTime || 0,
    timeToFirstToken: result.metrics?.timeToFirstToken || 0,
    totalDuration: result.metrics?.totalDuration || 0,
    bytesRead: result.sqlResult?.statistics?.bytes_read || 0,
    rowsRead: result.sqlResult?.statistics?.rows_read || 0,
    queryLength: result.sql?.length || 0,
    attempts: result.attempts?.map((a) => ({
      question: { question: a.question.question },
    })) || [{ question: { question: "" } }],
    success: result.sqlResult?.success ?? false,
    firstAttempt:
      result.model === "human"
        ? true
        : (result.attempts?.length === 1 && result.sqlResult?.success) ?? false,
    exactnessScore: exactnessScore || 0,
    tokens: result.metrics?.tokens?.totalTokens || 0,
  };
}

const QuestionCell = ({ metric }: { metric: QuestionMetric }) => {
  const question = metric.attempts?.[0]?.question?.question || metric.question;

  return (
    <div className={`max-w-[475px] -m-4 p-4`}>
      <div className="truncate" title={question}>
        {question}
      </div>

      <PreviewModal metric={metric as any} />
    </div>
  );
};

export default function ModelDetail() {
  const params = useParams();
  const modelName = decodeURIComponent(params.modelname as string);

  const questionMetrics = useMemo(() => {
    let modelResults;
    if (modelName === "human") {
      modelResults = typedHumanResults.filter((r) => r.model === "human");
    } else {
      modelResults = typedBenchmarkResults.filter((r) => r.model === modelName);
    }
    return modelResults.map(calculateQuestionMetrics);
  }, [modelName]);

  const columns = [
    {
      name: "Question",
      accessorKey: "question",
      sortable: true,
      description: "The question that was asked to the model",
      cell: (row: QuestionMetric) => {
        return <QuestionCell metric={row} />;
      },
    },
    {
      name: "Valid Query",
      accessorKey: "success",
      sortable: true,
      description: "Whether the query generated by the model is valid",
      cell: (row: QuestionMetric) => {
        return (
          <Badge status={row.success ? "success" : "error"}>
            {row.success ? "Success" : "Failed"}
          </Badge>
        );
      },
      type: "right" as const,
    },
    {
      name: "First Attempt",
      accessorKey: "firstAttempt",
      sortable: true,
      description: "Whether the query execution succeeded on the first try",
      cell: (row: QuestionMetric) => {
        return (
          <Badge status={row.firstAttempt ? "success" : "warning"}>
            {row.firstAttempt ? "Yes" : "No"}
          </Badge>
        );
      },
      type: "right" as const,
    },
    {
      name: "Exactness",
      accessorKey: "exactnessScore",
      sortable: true,
      description: "How similar the model's output is to the human's output",
      cell: (row: QuestionMetric) => {
        return (
          <div className="inline-flex items-center">
            <div
              className={`w-2 h-2 rounded-full mr-2 ${
                row.exactnessScore > 75
                  ? "bg-[#27F795]"
                  : row.exactnessScore >= 50
                  ? "bg-[#F7D727]"
                  : "bg-[#F72727]"
              }`}
            />
            <span className="font-mono">{row.exactnessScore.toFixed(2)}</span>
          </div>
        );
      },
      type: "right" as const,
    },
    {
      name: "Query Latency",
      accessorKey: "executionTime",
      sortable: true,
      description: "Time taken to execute the query in milliseconds",
      cell: (row: QuestionMetric) => (
        <span className="font-mono">
          {(row.executionTime * 1000).toLocaleString()} ms
        </span>
      ),
      type: "right" as const,
    },
    {
      name: "LLM Gen",
      accessorKey: "totalDuration",
      sortable: true,
      description: "Time for the LLM to generate the SQL query in seconds",
      cell: (row: QuestionMetric) => (
        <span className="font-mono">
          {row.totalDuration.toLocaleString()} s
        </span>
      ),
      type: "right" as const,
    },
    {
      name: "Attempts",
      accessorKey: "attempts",
      sortable: true,
      description: "Number of attempts needed for this query",
      cell: (row: QuestionMetric) => (
        <span className="font-mono">{row.attempts.length}</span>
      ),
      type: "right" as const,
    },
    {
      name: "Rows Read",
      accessorKey: "rowsRead",
      sortable: true,
      description: "Number of rows read by this query (lower is better)",
      cell: (row: QuestionMetric) => (
        <span className="font-mono">{row.rowsRead.toLocaleString()}</span>
      ),
      type: "right" as const,
    },
    {
      name: "Data Read",
      accessorKey: "bytesRead",
      sortable: true,
      description: "Amount of data read by this query in MB",
      cell: (row: QuestionMetric) => (
        <span className="font-mono">
          {(row.bytesRead / (1024 * 1024)).toLocaleString(undefined, {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2,
          })}{" "}
          MB
        </span>
      ),
      type: "right" as const,
    },
    {
      name: "Query Length",
      accessorKey: "queryLength",
      sortable: true,
      description: "Length of the generated SQL query in characters",
      cell: (row: QuestionMetric) => (
        <span className="font-mono">{row.queryLength}</span>
      ),
      type: "right" as const,
    },
    {
      name: "Tokens",
      accessorKey: "tokens",
      sortable: true,
      description: "Number of tokens used to generate the query",
      cell: (row: QuestionMetric) => (
        <span className="font-mono">{row.tokens.toLocaleString()}</span>
      ),
      type: "right" as const,
    },
  ];

  if (questionMetrics.length === 0) {
    return (
      <div className="min-h-screen p-8 font-sans">
        <div className="mb-8">
          <Link
            href="/"
            className="text-white hover:text-[#27F795] flex items-center gap-2"
          >
            <ArrowLeftIcon /> Back
          </Link>
        </div>
        <div className="text-center text-xl">
          No results found for model: {modelName}
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen py-8 px-4 lg:px-8 font-sans">
      <div className="mb-8">
        <Link
          href="/"
          className="text-white hover:text-[#27F795] flex items-center gap-2"
        >
          <ArrowLeftIcon /> Back
        </Link>
      </div>

      <h1 className="text-3xl mb-8">Detailed Results for {modelName}</h1>

      <div className="overflow-x-auto">
        <Table<QuestionMetric>
          columns={columns}
          data={questionMetrics}
          defaultSort={{
            key: "question",
            direction: "asc",
          }}
        />
      </div>
    </div>
  );
}
